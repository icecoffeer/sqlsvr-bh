SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE PROCEDURE [dbo].[OrdDvidByQttLmt](
	@NUM VARCHAR(10),
	@MODULENO INT,
	@FILLER INT,
	@MSG VARCHAR(256) OUTPUT
) AS
BEGIN
	--声明
    DECLARE @QTTLMT INT;
	DECLARE @LINE_NO INT;
	DECLARE @LMT INT;
	DECLARE @TMP_I INT;
	DECLARE @TOTAL MONEY;
	DECLARE @TOTALALL MONEY;
	DECLARE @TAX MONEY;
	DECLARE @COUNT INT;
	DECLARE @PREPAYALL MONEY;
	DECLARE @PREPAY MONEY;
	DECLARE @PREPAYED MONEY;
	DECLARE @NUMNEW VARCHAR(10);

	--判断定货单是否存在
	IF NOT EXISTS(SELECT 1 FROM ORD WHERE NUM = @NUM AND STAT in (0,7))
		BEGIN
			SET @MSG = '需要拆分的定货单不存在！';
			RETURN 1;
  		END

	--判断定货单中是否有商品   
	IF NOT EXISTS(SELECT 1 FROM ORDDTL WHERE NUM = @NUM)
  		BEGIN
    		SET @MSG = '需要拆分的定货单没有商品！';
    		RETURN 1;
  		END;

	--获取商品记录数限制
	EXEC OPTREADINT @MODULENO, 'GdQttLmt', 0, @QTTLMT OUTPUT;
	SET @LMT = @QTTLMT;

	--判断是否需要限制
	IF @QTTLMT <= 0
		BEGIN
			SET @MSG = '定单的商品记录数无限制！';
			RETURN 1;
		END;

	--检查记录数是否超出了限制而需要拆分
	SET @COUNT = (SELECT RECCNT FROM ORD WHERE NUM = @NUM);
	IF @COUNT <= @LMT
		BEGIN
			SET @MSG = '定单的商品记录数没有超出限制，不需要拆分！';
			RETURN 1;
		END;

	--初始值
	SET @TMP_I = 0;
	SET @TOTAL = 0;
	SET @TOTALALL = (SELECT TOTAL FROM ORD WHERE NUM = @NUM);
	SET @TAX = 0;
	SET @PREPAYALL = (SELECT PREPAY FROM ORD WHERE NUM = @NUM);
	SET @PREPAY = 0;
	SET @PREPAYED = 0;

	--抢占新的单号
	SELECT @NUMNEW = ISNULL(MAX(NUM), '0000000001') FROM ORD(NOLOCK);
	EXEC NEXTBN @NUMNEW, @NUMNEW OUTPUT;


	DECLARE LINE_CURSOR CURSOR FOR
		SELECT LINE FROM ORDDTL WHERE NUM = @NUM;
	OPEN LINE_CURSOR;
	FETCH NEXT FROM LINE_CURSOR INTO @LINE_NO;
	WHILE @@FETCH_STATUS = 0
		BEGIN
			
			--插入定单明细表
			INSERT ORDDTL
			(SETTLENO,NUM,LINE,GDGID,CASES,QTY,PRICE,TOTAL,TAX,VALIDDATE,WRH,
				INVQTY,ARVQTY,ASNQTY,ALLINVQTY,NOTE,FROMGID,FLAG,INUSE,LOCKNUM,
				LOCKCLS,SUBWRH)
			SELECT
			SETTLENO,@NUMNEW,@LINE_NO - @QTTLMT * @TMP_I,GDGID,CASES,QTY,PRICE,TOTAL,TAX,VALIDDATE,WRH,
				INVQTY, ARVQTY, ASNQTY, ALLINVQTY ,NOTE, FROMGID, FLAG, INUSE, LOCKNUM,
				LOCKCLS, SUBWRH
 			FROM ORDDTL WHERE NUM = @NUM AND LINE = @LINE_NO;

			--取出含税金额和税额
			SET @TOTAL = @TOTAL + (SELECT TOTAL FROM ORDDTL WHERE NUM = @NUM AND LINE = @LINE_NO);
			SET @TAX = @TAX + (SELECT TAX FROM ORDDTL WHERE NUM = @NUM AND LINE = @LINE_NO);

    		--写入新的定单号
			IF @MSG <> ''
				BEGIN
					SET @MSG = @MSG + ', '
				END;
			SET @MSG = @MSG + @NUMNEW;

			--达到限制时
			IF (@LINE_NO = @LMT) OR (@LINE_NO = @COUNT)
				BEGIN

					--计算预付款金额		
					IF (@LINE_NO = @COUNT)
						BEGIN
							SET @PREPAY = @PREPAYALL - @PREPAYED;
						END;	
					ELSE
						BEGIN
							SET @PREPAY = @PREPAYALL * (@TOTAL / @TOTALALL);
						END;

					--把新的定单插入定单表
					INSERT ORD 
					(NUM, SETTLENO, VENDOR, TOTAL, TAX, NOTE, FILDATE, PAYDATE, PREPAY, FILLER,
						CHECKER, STAT, MODNUM, WRH, RECCNT, SRC, SRCNUM, SNDTIME, RECEIVER, PSR,
						PRNTIME, FINISHED, EXPDATE, ALCCLS, PRECHECKER, PRECHKDATE, DLVBDATE,
						DLVEDATE, IMPFLAG, ALCGID, TAXRATELMT, DEPT, STAT2)
					SELECT
		 			@NUMNEW,SETTLENO,VENDOR,@TOTAL,@TAX,NOTE + '(由定货单' + @NUM + '拆分得到)',GETDATE(),PAYDATE,@PREPAY,@FILLER,
						CHECKER, STAT, MODNUM, WRH, (@LINE_NO - @QTTLMT * @TMP_I), SRC, SRCNUM, SNDTIME, RECEIVER, PSR,
						NULL, FINISHED, EXPDATE, ALCCLS, PRECHECKER, PRECHKDATE, DLVBDATE,
						DLVEDATE, IMPFLAG, ALCGID, TAXRATELMT, DEPT, STAT2
		 			FROM ORD WHERE NUM = @NUM;

					--增大范围
					SET @LMT = @LMT + @LMT;

					SET @TMP_I = @TMP_I + 1;

					--开始新的定单，把含税金额和税额设为零
					SET @TOTAL = 0;
					SET @TAX = 0;

					--已经分配的预付款
					SET @PREPAYED = @PREPAYED + @PREPAY;

					--抢占新的单号
					SELECT @NUMNEW = ISNULL(MAX(NUM), '0000000001') FROM ORD(NOLOCK);
					EXEC NEXTBN @NUMNEW, @NUMNEW OUTPUT;

				END;


			FETCH NEXT FROM LINE_CURSOR INTO @LINE_NO;
		END;
	CLOSE LINE_CURSOR;
	DEALLOCATE LINE_CURSOR;	

	--删除定货单
	DELETE FROM ORD WHERE NUM = @NUM;
	DELETE FROM ORDDTL WHERE NUM = @NUM;

	RETURN 0;

END;
GO
