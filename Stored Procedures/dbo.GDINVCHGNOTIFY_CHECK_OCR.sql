SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE PROCEDURE [dbo].[GDINVCHGNOTIFY_CHECK_OCR]
(
  @NUM CHAR(14),
  @OPER CHAR(30),
  @CLS CHAR(10),
  @TOSTAT INT,
  @MSG VARCHAR(255) OUTPUT
)
AS
BEGIN
  DECLARE
    @STOREGID INT,
    @RET INT,
    @SETPKG INT,
    @SRC INT,
    @OUTGDGID INT,
    @INGDGID INT,
    @RELQTY MONEY,
    @NOTE VARCHAR(100),
    @WRH INT,
    @QTY MONEY,
    @NEWBILLNUM CHAR(10),
    @LINENO INT,
    @OPTPRICE VARCHAR(100),
    @TAXRATE MONEY,
    @SELSTRING NVARCHAR(500),
    @CASES MONEY,
    @INPRC MONEY,
    @PRICE MONEY,
    @QTY2 MONEY,
    @SETTLENO INT,
    @TOTAL MONEY,
    @RTLPRC MONEY,
    @WRH2 INT,
    @TAX MONEY,
    @FILLER INT,
    @INPRC2 MONEY,
    @PRICE2 MONEY,
    @RTLPRC2 MONEY,
    @CASES2 MONEY,
    @LINE INT,
    @EXDIRECT INT

  SELECT @SETPKG = SETPKG, @SRC = SRC, @EXDIRECT = EXDIRECT FROM GDINVCHGNOTIFY(NOLOCK) WHERE NUM = @NUM

  IF @EXDIRECT = 1 
  BEGIN
    EXEC @RET = GDINVCHGNOTIFY_DOCHECK @NUM, @MSG OUTPUT
    IF @RET <> 0 RETURN @RET
  END
  
  IF @EXDIRECT = 1 
  BEGIN
    EXEC OPTREADSTR 468, 'DEFAULTPRICE', 'INPRC', @OPTPRICE OUTPUT

    SELECT @NEWBILLNUM = ISNULL(MAX(NUM), '0000000000') FROM GDINVCHG(NOLOCK)
    EXEC NEXTBN @NEWBILLNUM, @NEWBILLNUM OUTPUT

    --插入库存转移关系
    INSERT INTO INVCHG (SRC, GDGID, GDGID2, RELQTY)
    SELECT @SRC, D.OUTGDGID, D.INGDGID, D.RELQTY
    FROM GDINVCHGNOTIFYDTL D
    WHERE D.NUM = @NUM AND NOT EXISTS
      (SELECT 1 FROM INVCHG WHERE GDGID = D.OUTGDGID AND GDGID2 = D.INGDGID)

    UPDATE INVCHG
    SET RELQTY = D.RELQTY, SRC = @SRC
    FROM GDINVCHGNOTIFYDTL D
    WHERE GDGID = D.OUTGDGID AND GDGID2 = D.INGDGID AND D.NUM = @NUM

    SET @LINENO = 1
    DECLARE C CURSOR FOR
      SELECT D.OUTGDGID, D.INGDGID, D.RELQTY, D.NOTE, I.WRH, I.QTY, D.LINE
      FROM GDINVCHGNOTIFYDTL D(NOLOCK), INV I(NOLOCK), FASYSTEM S(NOLOCK)
      WHERE D.NUM = @NUM AND D.OUTGDGID = I.GDGID AND I.STORE = S.USERGID AND I.QTY <> 0
      ORDER BY D.LINE, D.OUTGDGID
    OPEN C
    FETCH NEXT FROM C INTO @OUTGDGID, @INGDGID, @RELQTY, @NOTE, @WRH, @QTY, @LINE
    WHILE @@FETCH_STATUS = 0
    BEGIN
      SELECT @CASES = @QTY / QPC, @TAXRATE = TAXRATE, @INPRC = INPRC, @RTLPRC = RTLPRC
      FROM GOODS(NOLOCK)
      WHERE GID = @OUTGDGID

      SET @SELSTRING = 'SELECT @PRICE = ' + @OPTPRICE + ' FROM GOODS(NOLOCK) WHERE GID = '
        + RTRIM(LTRIM(STR(@OUTGDGID)))
      EXECUTE SP_EXECUTESQL @SELSTRING, N'@PRICE MONEY OUTPUT', @PRICE = @PRICE OUTPUT

      SET @QTY2 = @QTY * @RELQTY
      SELECT @WRH2 = WRH, @CASES2 = @QTY2 / QPC, @PRICE2 = @PRICE / @RELQTY,
        @INPRC2 = INPRC, @RTLPRC2 = RTLPRC
      FROM GOODS(NOLOCK)
      WHERE GID = @INGDGID

      INSERT INTO GDINVCHGDTL (NUM, LINE, GDGID, GDGID2, WRH, WRH2, CASES,
        QTY, PRICE, TOTAL, TAX, INPRC, RTLPRC, INPRC2, RTLPRC2,
        RELQTY, QTY2, CASES2, PRICE2)
      VALUES (@NEWBILLNUM, @LINENO, @OUTGDGID, @INGDGID, @WRH, @WRH2, @CASES,
        @QTY, @PRICE, @PRICE * @QTY, @PRICE * @QTY * @TAXRATE / 100, @INPRC, @RTLPRC, @INPRC2, @RTLPRC2,
        @RELQTY, @QTY2, @CASES2, @PRICE2)
    
      INSERT INTO GDINVCHGNOTIFYGENDTL (NUM, LINE, GENBILL, GENNUM, GENLINE) VALUES 
      (@NUM, @LINE, '库存转移单', @NEWBILLNUM, @LINENO)
    
      SET @LINENO = @LINENO + 1
    
      FETCH NEXT FROM C INTO @OUTGDGID, @INGDGID, @RELQTY, @NOTE, @WRH, @QTY, @LINE
    END
    CLOSE C
    DEALLOCATE C
    
    IF @SETPKG = 1
    BEGIN  
      DECLARE C CURSOR FOR
        SELECT D.OUTGDGID, D.INGDGID, D.RELQTY, D.LINE
        FROM GDINVCHGNOTIFYDTL D(NOLOCK)
        WHERE D.NUM = @NUM
        ORDER BY D.LINE
      OPEN C
      FETCH NEXT FROM C INTO @OUTGDGID, @INGDGID, @RELQTY, @LINE
      WHILE @@FETCH_STATUS = 0
      BEGIN
        IF NOT EXISTS(SELECT 1 FROM PKG(NOLOCK) WHERE PGID = @OUTGDGID)
          INSERT INTO PKG (PGID, EGID, QTY) VALUES (@OUTGDGID, @INGDGID, @RELQTY)
        ELSE IF EXISTS(SELECT 1 FROM PKG(NOLOCK) WHERE PGID = @OUTGDGID AND EGID = @INGDGID)
          UPDATE PKG SET QTY = @RELQTY WHERE PGID = @OUTGDGID AND EGID = @INGDGID
        ELSE IF EXISTS(SELECT 1 FROM PKG(NOLOCK) WHERE PGID = @OUTGDGID AND EGID <> @INGDGID)
          UPDATE GDINVCHGNOTIFYDTL SET NOTE = LTRIM(RTRIM(NOTE))
            + '此行不能建立大小包装关系，因为大包装商品已经对应其它基本商品。'
          WHERE NUM = @NUM AND LINE = @LINE AND NOTE NOT LIKE '%因为大包装商品已经对应其它基本商品%'
        IF EXISTS(SELECT 1 FROM PKG(NOLOCK) WHERE PGID = @OUTGDGID)
          UPDATE GOODS SET ISPKG = 1 WHERE GID = @OUTGDGID
      
        FETCH NEXT FROM C INTO @OUTGDGID, @INGDGID, @RELQTY, @LINE
      END
      CLOSE C
      DEALLOCATE C
    END

    IF EXISTS(SELECT 1 FROM GDINVCHGDTL(NOLOCK) WHERE NUM = @NEWBILLNUM) 
    BEGIN
      SELECT @SETTLENO = MAX(NO) FROM MONTHSETTLE(NOLOCK)
      SELECT @TOTAL = ISNULL(SUM(TOTAL), 0), @TAX = ISNULL(SUM(TAX), 0) FROM GDINVCHGDTL(NOLOCK) WHERE NUM = @NEWBILLNUM
      SELECT @FILLER = GID FROM EMPLOYEE(NOLOCK)
      WHERE CODE = RTRIM(SUBSTRING(@OPER, CHARINDEX('[', @OPER) + 1, LEN(@OPER) - CHARINDEX('[', @OPER) - 1))

      INSERT INTO GDINVCHG (NUM, SETTLENO, TOTAL, TAX, FILDATE, FILLER, CHECKER, STAT,
        MODNUM, PSR, RECCNT, PRNTIME, PRECHECKER, PRECHKDATE, NOTE)
      VALUES (@NEWBILLNUM, @SETTLENO, @TOTAL, @TAX, GETDATE(), @FILLER, 1, 0,
        NULL, @FILLER, @LINENO - 1, NULL, 1, NULL, NULL)

      EXEC @RET = GDINVCHGCHK @NEWBILLNUM, 0, @MSG OUTPUT
      IF @RET <> 0 RETURN @RET
    END
  END ELSE BEGIN              
    DELETE FROM INVCHG WHERE LTRIM(STR(GDGID)) + '+' + LTRIM(STR(GDGID2)) 
      IN (SELECT LTRIM(STR(OUTGDGID)) + '+' + LTRIM(STR(INGDGID)) FROM GDINVCHGNOTIFYDTL(NOLOCK) WHERE NUM = @NUM)
    DELETE FROM PKG WHERE PGID IN (SELECT OUTGDGID FROM GDINVCHGNOTIFYDTL(NOLOCK) WHERE NUM = @NUM)
    UPDATE GOODS SET ISPKG = 0 WHERE GID IN (SELECT OUTGDGID FROM GDINVCHGNOTIFYDTL(NOLOCK) WHERE NUM = @NUM)   
  END

  UPDATE GDINVCHGNOTIFY SET
  STAT = 800, LSTUPDTIME = GETDATE()
  WHERE NUM = @NUM
  
  EXEC @RET = GDINVCHGNOTIFY_ADDLOG @NUM, '转换单', @TOSTAT, '生效', @OPER
  IF @RET <> 0 RETURN @RET

  SET @MSG = '单据：' + @NUM + '生效成功'

  RETURN 0
END
GO
